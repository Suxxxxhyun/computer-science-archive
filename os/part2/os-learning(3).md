## 프로그램, 프로세스, 프로세스 주소공간, 스레드
### 프로그램
- 코드를 컴파일한뒤, 하드디스크에 저장한 것

### 프로세스
- 실행파일(프로그램)이 RAM메모리에 적재되어 cpu를 할당받아 실행하는 것으로, 즉 실행중인 프로그램을 의미한다.
- 운영체제로부터 자원을 할당받는 작업의 단위 

### 프로세스 주소공간
- code 
  - 실행한 프로그램의 코드가 저장되는 영역으로, Read-Only영역으로 되어있다.
  - 컴파일시에 결정된다.
- data
  - 전역변수, static변수가 저장되는 메모리 영역
  - 컴파일시에 결정된다.
  - 초기화된 데이터는 data영역에 저장이 되고, 초기화되지 않은 데이터는 bss(Block Stated Symbol)영역에 저장이 된다.
  - 실행도중에 변경될 수 있기때문에 Read-Write로 지정되어있다.
- stack
  - 전역변수, 매개변수가 저장되는 메모리 영역
  - 높은 주소 -> 낮은 주소로 할당된다.
  - 컴파일 시에 크기가 결정된다.
- heap
  - 런타임중에 크기가 결정되는 메모리 영역
  - 낮은 주소 -> 높은 주소로 할당된다.
- code, data는 정적할당영역 / stack, heap은 동적할당영역


### 스레드
- 프로세스 안에서 실행되는 흐름의 단위로, stack영역을 제외한 나머지 영역을 공유하게 된다.
- **stack을 스레드마다 독립적으로 할당하는 이유?**
  - stack은 함수 호출시, 전달되는 인자, 되돌아갈 주소값 및 함수 내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간을 의미한다.
  - stack메모리 공간이 독립적이라는 것은, 독립적인 함수 호출이 가능하다는 것이고, 이것은 곧 독립적인 실행흐름을 추가되는 것을 의미한다.
  - 따라서, **스레드의 정의에 따라 독립적인 실행흐름을 추가하기 위해서 최소 조건으로 독립된 stack을 할당한다.**

### 스레드를 사용하는 이유?
- **멀티프로세스로 실행되는 작업을 멀티 스레드로 실행하게 되면, 프로세스를 생성하여 자원할당하는 과정도 줄어들고**
- **멀티프로세스로 context-switching하는 것보다 멀티스레드로 context-switching하는 것이 오버헤드를 더 줄일 수 있다.**

- 구글 docs를 이용하여 문서를 작성하는 경우
  - 하나의 구글 docs를 프로세스라고 생각하고 문서에 참여하는 사용자를 스레드라고 해보자.
  - 만약 멀티프로세스라고 하면, 사용자 한명당 하나의 구글 docs를 켜서 자신이 해야하는 임무를 마무리 하고 도출된 결과를 합쳐야할 것이고
  - 멀티스레드라고하면, 하나의 구글 docs에서 여러 사람들이 분배받은 커서를 이용하여 자신의 임무를 마무리하면 된다.

- 참조블로그
    - https://gyeong-log.tistory.com/30